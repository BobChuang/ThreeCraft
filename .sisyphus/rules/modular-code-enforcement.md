---
globs: ['**/*.ts', '**/*.tsx']
alwaysApply: false
description: 'Enforces strict modular code architecture: SRP, no monolithic index.ts, 200 LOC hard limit'
---

<MANDATORY_ARCHITECTURE_RULE severity="BLOCKING" priority="HIGHEST">

# 模块化代码架构 — 零容忍策略

此规则**不可协商**。违反此规则将**阻塞**所有后续工作，直到问题解决。

## 规则 1: index.ts 是入口文件，不是垃圾场

`index.ts` 文件**只能**包含：

- 重新导出 (`export { ... } from "./module"`)
- 组合模块的工厂函数调用
- 顶层注册/装配代码（hook 注册、插件配置）

`index.ts` **绝对不能**包含：

- 业务逻辑实现
- 工具/辅助函数
- 超出简单重新导出的类型定义
- 多个不相关的职责混合在一起

**如果你发现 index.ts 中有混合逻辑**：在进行任何其他修改之前，先将每个职责提取到独立文件中。这不是可选的。

## 规则 2: 禁止大杂烩文件 — utils.ts / service.ts 是代码坏味道

单个 `utils.ts`、`helpers.ts`、`service.ts` 或 `common.ts` 是一个**引力井** — 每个不相关的函数都会被丢进去，最终膨胀成一个不可测试、不可审查的巨型文件。

**这些文件名作为顶层大杂烩是被禁止的。** 替代方案：

| 反模式                                                 | 重构为                                                             |
| ------------------------------------------------------ | ------------------------------------------------------------------ |
| `utils.ts` 包含 `formatDate()`、`slugify()`、`retry()` | `date-formatter.ts`、`slugify.ts`、`retry.ts`                      |
| `service.ts` 处理认证 + 计费 + 通知                    | `auth-service.ts`、`billing-service.ts`、`notification-service.ts` |
| `helpers.ts` 有 15 个不相关的导出                      | 每个逻辑领域一个文件                                               |

**从一开始就为可复用性设计。** 每个模块应该：

- **可独立导入** — 使用方不应被迫引入不相关的代码
- **自包含** — 依赖是显式的，不是埋在共享杂货袋里
- **按用途命名** — 仅从文件名就能知道它做什么

如果你发现自己正在输入 `utils.ts` 或 `service.ts`，**停下来**，用它实际做的事情来命名文件。

## 规则 3: 单一职责原则 — 绝对遵守

每个 `.ts` 文件**必须**有且仅有**一个**清晰、可命名的职责。

**自检**：如果你无法用一个简短的短语描述文件的用途（例如 "解析 YAML frontmatter"、"将规则与文件路径匹配"），那么这个文件做了太多事情。拆分它。

| 信号                            | 行动                                        |
| ------------------------------- | ------------------------------------------- |
| 文件有 2 个以上不相关的导出函数 | **立即拆分** — 每个放入独立模块             |
| 文件混合了 I/O 和纯逻辑         | **立即拆分** — 分离副作用和计算             |
| 文件同时包含类型和实现          | **立即拆分** — types.ts + implementation.ts |
| 你需要滚动才能理解文件          | **立即拆分** — 文件太大了                   |

## 规则 4: 200 行代码硬限制 — 代码坏味道检测器

任何超过 **200 行代码**的 `.ts`/`.tsx` 文件（不含 prompt 字符串、包含 prompt 的模板字面量和 `.md` 内容）都是**立即代码坏味道**。

**当你检测到文件 > 200 LOC 时**：

1. **停止**当前工作
2. **识别**隐藏在文件中的多个职责
3. **提取**每个职责到独立的聚焦模块
4. **验证**每个结果文件 < 200 LOC 且只有一个用途
5. **恢复**原始工作

以 prompt 为主的文件（agent 定义、skill 定义），其中大部分内容是模板字面量 prompt 文本，**豁免** LOC 计数 — 但其非 prompt 逻辑仍必须 < 200 LOC。

### 如何计算 LOC

**计入这些**（= 实际逻辑）：

- Import 语句
- 变量/常量声明
- 函数/类/接口/类型定义
- 控制流 (`if`、`for`、`while`、`switch`、`try/catch`)
- 表达式、赋值、return 语句
- 属于逻辑块的闭合花括号 `}`

**排除这些**（= 非逻辑）：

- 空行
- 纯注释行 (`//`、`/* */`、`/** */`)
- 模板字面量中的 prompt/指令文本行（例如 `` const prompt = `...` `` 的字符串体）
- 用作文档/prompt 内容的多行字符串中的行

**快速方法**：读取文件 → 减去空行、纯注释行和 prompt 字符串内容 → 剩余计数 = LOC。

**示例**：

```typescript
// 1  import { foo } from "./foo";          ← 计入
// 2                                         ← 跳过（空行）
// 3  // Helper for bar                      ← 跳过（注释）
// 4  export function bar(x: number) {       ← 计入
// 5    const prompt = `                     ← 计入（声明）
// 6      You are an assistant.              ← 跳过（prompt 文本）
// 7      Follow these rules:                ← 跳过（prompt 文本）
// 8    `;                                   ← 计入（闭合）
// 9    return process(prompt, x);           ← 计入
// 10 }                                      ← 计入
```

→ LOC = **5**（第 1、4、5、9、10 行）。不是 10。

如有疑问，**向上取整** — 宁可多拆分。

## 如何应用

当读取、写入或编辑任何 `.ts`/`.tsx` 文件时：

1. **检查你正在修改的文件** — 它是否违反了上述任何规则？
2. **如果是** — 先重构，再继续你的任务
3. **如果创建新文件** — 确保它只有一个职责且不超过 200 LOC
4. **如果向现有文件添加代码** — 验证添加不会使文件超过 200 LOC 或增加第二个职责。如果会，提取到新模块中。

</MANDATORY_ARCHITECTURE_RULE>
